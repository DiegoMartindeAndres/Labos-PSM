# üöÄ Implementaci√≥n b√°sica de Navegaci√≥n en Jetpack Compose

En este laboratorio vamos a implementar la navegaci√≥n entre pantallas en nuestra aplicaci√≥n usando Jetpack Compose. üèóÔ∏è Comenzaremos creando la primera pantalla de la app y aprenderemos a transferir informaci√≥n de una pantalla a otra.

Para ello vamos a crear un nuevo proyecto con una actividad vac√≠a (Empty Activity). Llamaremos a este proyecto "Ejemplo de Navegaci√≥n".

# üìã Tabla de Contenidos 
- [üöÄ Implementaci√≥n b√°sica de Navegaci√≥n en Jetpack Compose](#-implementaci√≥n-b√°sica-de-navegaci√≥n-en-jetpack-compose)
- [üìã Tabla de Contenidos](#-tabla-de-contenidos)
- [üì± Configuraci√≥n de la Segunda Pantalla](#-configuraci√≥n-de-la-segunda-pantalla)
- [üß≠ Navegaci√≥n en Jetpack Compose](#-navegaci√≥n-en-jetpack-compose)
- [üì± Pasar Datos Entre Pantallas](#-pasar-datos-entre-pantallas)
- [üì¶ Problema que tiene esta estrategia de navegaci√≥n.](#-problema-que-tiene-esta-estrategia-de-navegaci√≥n)

### üåü Primera Pantalla: Entrada del Usuario

El objetivo inicial es crear una pantalla donde el usuario pueda introducir su nombre, y al pulsar un bot√≥n, se navegue hacia una nueva pantalla con esa informaci√≥n. 

La primera pantalla la crearemos en el fichero `FirstScreen.kt` 

```kotlin
@Composable
fun FirstScreen(paddingValues: PaddingValues) {
    var name by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Primera Pantalla", fontSize = 24.sp)
        Spacer(modifier = Modifier.height(16.dp))
        OutlinedTextField(
            value = name,
            onValueChange = { name = it },
            label = { Text("Introduce tu nombre") }
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = {
            // Aqu√≠ es donde deber√≠amos implementar la navegaci√≥n a la segunda pantalla.
        }) {
            Text("Ir a la segunda pantalla")
        }
    }
}

// Por si quieres hacer una preview del composable
@Preview(showBackground = true)
@Composable
fun PreviewFirstScreen() {
    FirstScreen(paddingValues = PaddingValues(0.dp))
}
```

Desde el `MainActivity`, llamaremos a este composable para que se muestre en la pantalla principal de la aplicaci√≥n. De la siguiente manera:

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            EjNavegacionTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    FirstScreen(innerPadding)
                }
            }
        }
    }
}
```

> **NOTA:** Recuerda que tendr√°s que importar los elementos necesarios para que el c√≥digo funcione correctamente. 

### üìã Explicaci√≥n de los elementos utilizados

- **OutlinedTextField**: Este campo permite al usuario introducir su nombre. Utilizamos una variable `name` para almacenar el valor introducido.
- **Button**: Al hacer clic en el bot√≥n, se navega hacia la segunda pantalla, pasando el valor del nombre como parte de la ruta.
- **remember { mutableStateOf("") }**: Se usa para almacenar y recordar el estado del nombre introducido por el usuario. Es una forma de manejar el estado en Jetpack Compose.
- **Column**: Organiza los elementos de forma vertical, centr√°ndolos tanto horizontal como verticalmente.
- **Spacer**: A√±ade espacio entre los elementos para mejorar la presentaci√≥n visual.

# üì± Configuraci√≥n de la Segunda Pantalla

Ahora, vamos a crear un archivo nuevo llamado `SecondScreen.kt` para la segunda pantalla. Para ello, podemos aprovechar gran parte del c√≥digo de la primera pantalla copi√°ndolo y adapt√°ndolo. A continuaci√≥n, te muestro c√≥mo se puede ver el c√≥digo de la segunda pantalla:

```kotlin
// SecondScreen.kt
@Composable
fun SecondScreen(paddingValues: PaddingValues) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Segunda Pantalla", fontSize = 24.sp)
        Text(
            text = "Bienvenido",
            fontSize = 24.sp
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = {
            // Aqu√≠ es donde deber√≠amos implementar la navegaci√≥n a la primera pantalla.
        }) {
            Text("Ir a la primera pantalla")
        }
    }
}

@Preview
@Composable
fun SecondScreenPreview() {
    SecondScreen(paddingValues = PaddingValues(0.dp))
}
```

Hemos realizado los siguientes cambios con respecto a la primera pantalla:
- Cambiado el nombre del composable a `SecondScreen`.
- Eliminado el campo `OutlinedTextField` que hab√≠a en la primera pantalla y lo hemos sustituido por un mensaje de bienvenida.
- Ajustado el tama√±o de fuente del texto a `24.sp` para hacerlo m√°s grande.
- Modificado el bot√≥n para que su acci√≥n sea navegar de vuelta a la primera pantalla.

# üß≠ Navegaci√≥n en Jetpack Compose

En este apartado configuraremos la navegaci√≥n dentro de nuestra aplicaci√≥n utilizando Jetpack Compose. Vamos a seguir una gu√≠a que nos muestra c√≥mo hacerlo paso a paso. La navegaci√≥n es esencial para moverse entre las diferentes pantallas de la app.

## ¬øQu√© es un NavController?

El `NavController` es una clase clave dentro de Jetpack Compose que facilita la navegaci√≥n entre diferentes pantallas o composables en una aplicaci√≥n m√≥vil. Act√∫a como un controlador que gestiona la pila de navegaci√≥n, permitiendo a los desarrolladores definir, controlar y ejecutar transiciones de una pantalla a otra de manera fluida. Es esencial para mantener la navegaci√≥n organizada, especialmente en aplicaciones con m√∫ltiples pantallas.

## C√≥mo funciona el NavController

En Jetpack Compose, el `NavController` permite definir rutas o destinos para cada pantalla de la aplicaci√≥n, que se conocen como `@Composable`. Este controlador sigue un enfoque basado en rutas, en donde cada pantalla se asocia a una ruta o *destino*. La navegaci√≥n se lleva a cabo utilizando dichas rutas, ya sea para mover al usuario de una pantalla a otra o para regresar a una pantalla previa.

`NavController` trabaja junto con el componente `NavHost`, que define todas las rutas y destinos posibles. `NavHost` es el encargado de asociar un `NavController` a una serie de pantallas (destinos) espec√≠ficas.

### ¬øQu√© es el BackStack?

El **BackStack** (pila de retroceso) es una estructura que mantiene un registro de las pantallas o destinos por los que el usuario ha navegado en la aplicaci√≥n. Cada vez que el `NavController` realiza una transici√≥n a una nueva pantalla, la pantalla actual se guarda en el *BackStack*, lo que permite al usuario regresar a pantallas anteriores utilizando la navegaci√≥n hacia atr√°s (como el bot√≥n de retroceso del sistema).

El `NavController` maneja autom√°ticamente el BackStack, lo cual permite que la experiencia de usuario sea fluida y coherente. Esto significa que cada vez que el usuario presiona el bot√≥n de retroceso, el `NavController` desempila la √∫ltima pantalla visitada y la muestra nuevamente, replicando la experiencia de navegaci√≥n com√∫n en aplicaciones m√≥viles.


¬øC√≥mo se implementa la navegaci√≥n en Jetpack Compose? A continuaci√≥n, te muestro un esquema de los pasos que m√°s adelante implementaremos.

1. **Agregar dependencias necesarias**

Aseg√∫rate de tener las siguientes dependencias a `androidx.navigation:navigation-compose` para poder usar su funcionalidad en tu proyecto:

M√°s adelante hablaremos de las versiones y como agregarlas a tu proyecto.

2. **Crear el NavHost y NavController**

Primero, debemos crear un `NavHost` que asocie el `NavController` con las pantallas de la aplicaci√≥n. 

Esa asociaci√≥n se suele hacer en una funci√≥n `@Composable` que act√∫a como la ra√≠z de la aplicaci√≥n. Aqu√≠ es donde se definen las rutas y destinos de la navegaci√≥n.

3. **Definir las pantallas y las rutas**

M√°s adelante se definen dos composables que representan las pantallas, en nuestro caso ser√°n `FirstScreen` y `SecondScreen`.

¬øTodo listo para empezar con la implementaci√≥n?
Vamos paso por paso.

### 1. Agregar dependencias üõ†Ô∏è

Primero, debemos agregar las dependencias necesarias para la navegaci√≥n en nuestro archivo `build.gradle` del m√≥dulo de la aplicaci√≥n. 

Usaremos la siguiente dependencia, a la fecha de creaci√≥n de este manual la versi√≥n es **2.8.4**, pero siempre elige la m√°s actualizada sin llegar a ser una versi√≥n alpha:

```kotlin
androidx.navigation:navigation-compose:2.8.4
```

Despu√©s de agregar la dependencia, sincroniza el proyecto para que se reconozcan las nuevas funcionalidades.

Puedes obtener m√°s informaci√≥n si visitas la [documentaci√≥n oficial de Jetpack Compose Navigation](https://developer.android.com/develop/ui/compose/navigation#kts).

### 2. Configurar el NavController üõ°Ô∏è

Una vez agregadas las dependencias, es necesario crear un `NavController`. El `NavController` es el componente encargado de manejar el estado y el *backstack* de las pantallas en nuestra app.

Para ello vamos a crear una nueva funci√≥n `@Composable` llamada `MyApp` que contendr√° el `NavHost` y las rutas de navegaci√≥n, la colocamos en el archivo `MyActivity.kt`:

```kotlin
@Composable
fun MyApp() {
    val navController = rememberNavController()
    NavHost(
        navController = navController,
        // OJO! este no es el nombre del composable, es el nombre de la ruta. Lo entender√°s m√°s abajo.
        startDestination = "firstscreen"
    ) {
        composable("firstscreen") { 
            // Este es el nombre de la ruta que usamos como inicio.
            // Aqu√≠ se coloca la llamada al composable de la primera pantalla.
        
        }
        composable("secondscreen") {
            // Aqu√≠ se coloca la llamada al composable de la segunda pantalla.
        }
    }
}
```

### 3. Definir las pantallas üóÉÔ∏è

Las pantallas se definen como funciones `@Composable`. A cada pantalla se le asocia una ruta dentro del `NavHost` para poder ser identificada y usada durante la navegaci√≥n.

- **Pantalla Inicial (FirstScreen)**:
  
  La funci√≥n `FirstScreen` recibe un par√°metro `onNavigateToSecondScreen` que es una funci√≥n lambda que se ejecuta cuando queremos navegar a la segunda pantalla.


    ```kotlin
    @Composable
    fun FirstScreen(onNavigateToSecondScreen: () -> Unit) {
        // Hay m√°s c√≥digo eliminado, solo marcamos la parte importante.
        Button(onClick = onNavigateToSecondScreen) {
            Text("Ir a la segunda pantalla")
        }
    }
    ```

- **Segunda Pantalla (SecondScreen)**:
  En este caso, la funci√≥n `SecondScreen` recibe un par√°metro `onNavigateToFirstScreen` que es una funci√≥n lambda que se ejecuta cuando queremos navegar a la primera pantalla.

    ```kotlin
    @Composable
    fun SecondScreen(onNavigateToFirstScreen: () -> Unit) {
        // Hay m√°s c√≥digo eliminado, solo marcamos la parte importante.
        Button(onClick = onNavigateToFirstScreen) {
            Text("Volver a la primera pantalla")
        }
    }
    ```

### 4. Configurar el Navegador (NavHost) üö™

El `NavHost` es el componente principal que se utiliza para definir la navegaci√≥n entre las pantallas. Se le pasa un `NavController` y se define cu√°l es la pantalla inicial (`startDestination`). Adem√°s, se establecen los diferentes `composables` que representan cada pantalla.

- El **NavHost**:

    ```kotlin
    @Composable
    fun MyApp() {
        val navController = rememberNavController()
        NavHost(
            navController = navController,
            startDestination = "firstscreen"
        ) {
            composable("firstscreen") { 
                FirstScreen(
                    onNavigateToSecondScreen = {
                        navController.navigate("secondscreen") 
                    }
                )
            }
            composable("secondscreen") {
                SecondScreen(
                    onNavigateToFirstScreen = {
                        navController.navigate("firstscreen")
                    }
                )
            }
        }
    }
    ```

### 5. Adaptar `MainActivity` üõãÔ∏è

Ahora desde MainActivity debemos llamar a la funci√≥n `MyApp` para que se muestre en la pantalla principal de la aplicaci√≥n. Y para no tener problemas con el `innerPadding`, vamos a "encapsularlos" en un `Box`:

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            EjNavegacionTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    Box(modifier = Modifier.padding(innerPadding)) {
                        MyApp() // Llamas a MyApp que gestiona el NavHost
                    }
                }
            }
        }
    }
}
```

### 6. Ejecutar la navegaci√≥n y probarla üî•

Si todo est√° correcto, se ejecutar√° tu aplicaci√≥n y podr√°s navegar entre una pantalla a otra. Pero si te fijas no se pasar√≠a el nombre de la persona de una pantalla a otra, eso lo veremos en el siguiente apartado.

### Reto 1: A√±ade una tercera pantalla

¬øSer√≠as capaz de crear una tercera pantalla?
De tal manera que el ciclo entre pantallas sea: 

`FirstScreen` -> `SecondScreen` -> `ThirdScreen` -> `FirstScreen`.

Puedes copiar la tercera pantalla de la segunda o la primera, pero cambia un poco la tercera pantalla para que se pueda leer que est√°s en la tercera pantalla.

¬°√Ånimo! üöÄ

# üì± Pasar Datos Entre Pantallas 

Las partes que tenemos que cambiar para poder pasar informaci√≥n de una pantalla a otra son las siguientes:

1. La pantalla que recibe la informaci√≥n debe tener un par√°metro en su funci√≥n `@Composable` que reciba la informaci√≥n. En nuestro caso ser√° un `String` con el nombre.
2. Desde la pantalla que env√≠a la informaci√≥n, debemos pasarla como par√°metro al navegar a la siguiente pantalla. En nuestro caso, desde `FirstScreen` debemos pasar el nuevo par√°metro.
3. Pero esto no es suficiente, tambi√©n debemos modificar el `NavHost` para que pueda recibir el par√°metro y pasarlo a la pantalla correspondiente.

Vamos a verlo paso a paso con el ejemplo de las pantallas. Yo lo tengo hecho con tres pantallas.

### üöÄ Paso a Paso para la Navegaci√≥n entre Pantallas

Vamos a aprender c√≥mo pasar datos de una pantalla a otra utilizando Kotlin y Jetpack Compose. El objetivo es pasar un nombre desde la primera pantalla hacia la segunda pantalla y luego mostrarlo.

#### 1. üìç Definir el Par√°metro en la Segunda Pantalla

En nuestra segunda pantalla, especificamos que cuando sea llamada, deber√° recibir un par√°metro llamado `name` de tipo `String`, adem√°s de la funci√≥n lambda `onNavigateToThridScreen` (si has hecho el ejercicio o `onNavigateToFirstScreen` si no lo has hecho) que se ejecutar√° al navegar a la siguiente pantalla.

Adem√°s, en la segunda pantalla no vamos a decir simplemente "Bienvenido", sino que vamos a mostrar el nombre que se ha pasado como par√°metro.

```kotlin
@Composable
fun SecondScreen(name: String, onNavigateToThirdScreen: () -> Unit) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Segunda Pantalla", fontSize = 24.sp)
        Text(
            text = "Bienvenido $name",
            fontSize = 24.sp
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = onNavigateToThirdScreen) {
            Text("Ir a la tercera pantalla")
        }
    }
}

@Preview
@Composable
fun SecondScreenPreview() {
    SecondScreen(name= "Bartolo", {})
}
```

En la vista previa de la segunda pantalla, podemos pasar un valor ejemplo.


#### 2. üñ± Navegar desde la Primera Pantalla

Para navegar a la segunda pantalla y pasar el nombre, necesitamos pasar la variable correspondiente al hacer clic en un bot√≥n, esa informaci√≥n la tenemos en una variable `name` con el valor ingresado por el usuario:

```kotlin
var name by remember { mutableStateOf("") }
```

En la funci√≥n lambda que tenemos que pasar a FirstScreen debemos pasar el nombre que es de tipo `String`. Por lo tanto la cabecera de la funci√≥n se nos queda as√≠:
    
```kotlin
@Composable
fun FirstScreen(onNavigateToSecondScreen: (String) -> Unit) {
    ...
}
```

Y posteriormente, cuando pulsen el bot√≥n y se ejecute el evento `onClick`, pasamos el valor de la variable `name`:

```kotlin
        Button(onClick = {
            onNavigateToSecondScreen( name )
        })
```

De esta manera, estamos pasando el valor del nombre a la segunda pantalla.

#### 3. üõ† Configurar el NavHost para la Navegaci√≥n

Esta quiz√° sea la parte m√°s complicada de entender, en la funci√≥n `MyApp` debemos modificar las llamadas para reflejar el paso de par√°metros entre pantallas.

En la actividad principal, configuramos el `NavHost` para manejar la navegaci√≥n entre nuestras pantallas.

Hay que tocar en dos partes:

1. En la definici√≥n de `FirstScreen`, en el evento `onNavigateToSecondScreen` debemos pasar el nombre. Y adem√°s eso se lo debemos definir al `NavController` para que lo pueda pasar a la segunda pantalla.

De tal manera que el c√≥digo se nos quedar√≠a de la siguiente manera:

```kotlin
        composable("firstscreen") {
            FirstScreen(
                onNavigateToSecondScreen = { name ->
                    navController.navigate("secondscreen/$name")
                }
            )
        }
```

1. En la definici√≥n de `SecondScreen`, la funci√≥n debe aceptar un `String` en la definici√≥n de la ruta. Y adem√°s, la funci√≥n `SecondScreen` acepta un `String`, por lo tanto debemos definirlo.

    ```kotlin
    // OJO!! este c√≥digo tiene un error.
        composable("secondscreen/{name}") {
            SecondScreen(name)(
                onNavigateToThirdScreen = {
                    navController.navigate("thirdscreen")
                }
            )
        }
    ```

Si te fijas, no se sabe bien que es `name`, sabemos que es lo que tenemos que pasarle a la funci√≥n, pero ¬øDe donde lo sacamos?

- Debemos obtenerlo de los argumentos que recibe la ruta, y eso lo hacemos con el siguiente c√≥digo:

    ```kotlin
    val name = it.arguments?.getString("name") ?: "sin nombre"
    ```

Este c√≥digo en Kotlin realiza lo siguiente:

1. **`it.arguments?.getString("name")`**: Intenta obtener el valor del argumento `"name"` de un objeto `it` (en este caso `it` es un `NavBackStackEntry`, donde podemos mirar los par√°metros, pero no vamos a entrar en ello, simplmente vamos a aprender a obtenerlos.).
   - **`arguments`**: Es un `Bundle` que contiene los argumentos, y vamos a preguntar por el que nos interesan, en este caso `"name"`.
   - **`?.`**: Utiliza el operador seguro para evitar excepciones si `arguments` es `null`. Si `arguments` es `null`, toda la expresi√≥n se vuelve `null`.

2. **`?: "sin nombre"`**: Si el valor obtenido es `null` (es decir, si no existe un argumento `"name"` o `arguments` es `null`), se usa el operador Elvis (`?:`) para asignar un valor predeterminado: `"sin nombre"`.

En resumen, `name` contendr√° el valor del argumento `"name"` si est√° presente, y en caso contrario contendr√° el valor `"sin nombre"`.

La definici√≥n del completa del `NavHost` se nos quedar√≠a de la siguiente manera:

```kotlin
@Composable
fun MyApp() {
    val navController = rememberNavController()
    NavHost(
        navController = navController,
        startDestination = "firstscreen"
    ) {
        composable("firstscreen") {
            FirstScreen(
                onNavigateToSecondScreen = { name ->
                    navController.navigate("secondscreen/$name")
                }
            )
        }
        composable("secondscreen/{name}") {
            val name = it.arguments?.getString("name") ?: "sin nombre"
            SecondScreen(name,
                onNavigateToThirdScreen = {
                    navController.navigate("thirdscreen")
                }
            )
        }

    // Aqu√≠ el c√≥digo de una tercera pantalla si la tuvieras

    }
}
```

Ir a la √∫ltima secci√≥n. Problema que tiene esta estrategia de navegaci√≥n.

#### üîÑ Resumen del Flujo

1. **Primera Pantalla**: Capturamos el nombre del usuario y navegamos a la segunda pantalla pasando ese nombre como par√°metro.
2. **Segunda Pantalla**: Recibimos el nombre y lo mostramos en un mensaje de bienvenida.
3. **NavHost**: Configuramos las rutas de navegaci√≥n, especificando que la segunda pantalla debe recibir un par√°metro `name`.

Te recomiendo que revises tu c√≥digo y asientes estos conceptos, ya que los vamos a utilizar siempre que queramos pasar informaci√≥n entre pantallas.

#### Prueba tu c√≥digo.

Si lo has hecho bien, podr√°s pasar de la primera pantalla a la segunda pantalla y ver el nombre que has introducido en la primera pantalla. üòä

### Reto 2: Pasa tu edad a la tercera pantalla

El flujo entre pantallas que hab√≠amos definido era:

`FirstScreen` -> `SecondScreen` -> `ThirdScreen` -> `FirstScreen`.

Y de momento los datos que pasamos son el nombre, entre `FirstScreen` a `SecondScreen`.

Pues bien, ahora queremos que en la `SecondScreen` se pregunte por la edad y se env√≠e, junto con el nombre, a `ThirdScreen`.

¬øSer√≠as capaz de hacerlo? üöÄ

<details>
  <summary>Necesitas ayuda con el c√≥digo.</summary>
<br>

#### MainActivity.kt

Omito los imports para no hacerlo tan largo.

```kotlin
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        enableEdgeToEdge()
        setContent {
            EjNavegacionTheme {
                Scaffold(modifier = Modifier.fillMaxSize()) { innerPadding ->
                    Box(modifier = Modifier.padding(innerPadding)) {
                        MyApp() // Llamas a MyApp que gestiona el NavHost
                    }
                }
            }
        }
    }
}


@Composable
fun MyApp() {
    val navController = rememberNavController()
    NavHost(
        navController = navController,
        startDestination = "firstscreen"
    ) {
        composable("firstscreen") {
            FirstScreen(
                onNavigateToSecondScreen = { name ->
                    navController.navigate("secondscreen/$name")
                }
            )
        }
        composable("secondscreen/{name}") {
            val receivedName  = it.arguments?.getString("name") ?: "sin nombre"
            SecondScreen(receivedName,
                onNavigateToThirdScreen = { nameToPass, age ->
                    navController.navigate("thirdscreen/$nameToPass/$age")
                }
            )
        }

        composable("thirdscreen/{name}/{age}") {
            val name = it.arguments?.getString("name") ?: "sin nombre"
            val age = it.arguments?.getString("age") ?: "0"
            ThirdScreen(name, age,
                onNavigateToFirstScreen = {
                    navController.navigate("firstscreen")
                }
            )
        }

    }
}
```

#### FirstScreen.kt

```kotlin
@Composable
fun FirstScreen(onNavigateToSecondScreen: (String) -> Unit) {
    var name by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Primera Pantalla", fontSize = 24.sp)
        Spacer(modifier = Modifier.height(16.dp))
        OutlinedTextField(
            value = name,
            onValueChange = { name = it },
            label = { Text("Introduce tu nombre") }
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = {
            onNavigateToSecondScreen( name )
        }) {
            Text("Ir a la segunda pantalla")
        }
    }
}

@Preview(showBackground = true)
@Composable
fun PreviewFirstScreen() {
    FirstScreen {}
}
```

#### SecondScreen.kt

```kotlin
@Composable
fun SecondScreen(name: String, onNavigateToThirdScreen: (String, String) -> Unit) {
    var age by remember { mutableStateOf("") }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Segunda Pantalla", fontSize = 24.sp)
        Text(
            text = "Bienvenido $name",
            fontSize = 24.sp
        )
        Spacer(modifier = Modifier.height(16.dp))
        OutlinedTextField(
            value = age,
            onValueChange = { age = it },
            label = { Text("Introduce tu edad") }
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = {
            onNavigateToThirdScreen (name, age)
        }) {
            Text("Ir a la tercera pantalla")
        }
    }
}

@Preview(showBackground = true)
@Composable
fun SecondScreenPreview() {
    SecondScreen(name= "Bartolo", onNavigateToThirdScreen = { name, age -> })
}
```

#### ThirdScreen.kt

```kotlin
@Composable
fun ThirdScreen(name: String, age: String, onNavigateToFirstScreen: () -> Unit) {
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(text = "Bienvenido a la tercera pantalla", fontSize = 24.sp)
        Text(
            text = "$name con edad $age",
            fontSize = 24.sp
        )
        Spacer(modifier = Modifier.height(16.dp))
        Button(onClick = onNavigateToFirstScreen) {
            Text("Ir a la primera pantalla")
        }
    }
}

@Preview(showBackground = true)
@Composable
fun ThirdScreenPreview() {
    ThirdScreen("Bartolo", "34") {}
}
```

</details>
<br>


# üì¶ Problema que tiene esta estrategia de navegaci√≥n.

Si te fijas en el c√≥digo donde implementamos la navegaci√≥n, hay un problema.

```kotlin
@Composable
fun MyApp() {
    val navController = rememberNavController()
    NavHost(
        navController = navController,
        startDestination = "firstscreen"
    ) {
        composable("firstscreen") {
            FirstScreen(
                onNavigateToSecondScreen = { name ->
                    navController.navigate("secondscreen/$name")
                }
            )
        }
        composable("secondscreen/{name}") {
            val name = it.arguments?.getString("name") ?: "sin nombre"
            SecondScreen(name,
                onNavigateToThirdScreen = {
                    navController.navigate("thirdscreen")
                }
            )
        }

    // Aqu√≠ el c√≥digo de una tercera pantalla si la tuvieras

    }
}
```
¬øAdivinas cual es el problema?

Con esta estrategia de navegaci√≥n solo podemos enviar y recibir tipos primitivos, b√°sicamente `String`, `Int`, `Boolean`, etc. Pero no podemos enviar objetos m√°s complejos, como por ejemplo un objeto `Persona` que tenga nombre, edad, direcci√≥n, etc.

¬øSe puede resolver?

Si, lo veremos en el siguiente manual. üöÄ